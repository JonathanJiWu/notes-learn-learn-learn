    WELCOME
    =========

*C++
    compiler ==> machine code
    hardware, game dev, fast, lower level

*java, C#
    compiler ==> visual machine ==> machine code


*HELLO WORLD FROM C++

    #include <iostream> ==>include libraries
    int main() {        ==>Main function
    std::cout << "Hello World!\n";  ==>function body
    }


@ OUTPUT

*execution
    top to down, line by line

*std::cout <<"Hello World!\n";
    std::cout ==>Standard(namespace), character output stream, pronounced "see-out"
    :: ==>scope
    << ==>operator
    "Hello World?\n" ==>is what being output, double quotes around text. \n indicates a new line.
    ; ==>end the statement

*namespace
    a set of signs(names)that are used to identify and refer to objects of various kinds.


@ PATTERN
    
*/n
    can print out several lines with one fucntion

@ COMPILE AND EXECUTE

*C++ is a compiled language, source code => compile => machine code => execute.

*compile
    turn/translate source code into machaine code

*g++
    type |g++ app-name.cpp| into terminal to call on the compiler

*execute
    type |./machine-code-file-name.out| in terminal

*process
    executable file => loaded to CPU => line by line


@ NAMING EXECUTABLES
    
*name executable & output & execute
    |g++ hello.cpp -o name-of-the-executable| 
    then
    |./name-of-the-executable| to execute

*COMMENTS
    |// comments here!|
    |/*comment,
    comment,
    comment.*/|

*source code suffix
    .cpp
    .h

    VARIABLE
    =========

*declare
    name+type
    | int score; |

*strongly typed
    
*initialize
    | score = 0; |

*arthmetic Operators
    +, -, *, /, %

*print out the value of variable
    std::cout << score << "\n";

*chaining
    int age = 28;
    std::cout << "Hello, I am ";
    std::cout << age;
    std::cout << " years old\n";
    output ==> Hello, I am 28 years old
    can be written as ==> std::cout << "Hello, I am " << age << " years old\n";

    #include <iostream>
    int main() { 
    int score = 0;
    std::cout << "Player score: " << score <<"\n";   
    }

*user input
    std::cout << "Enter your password: ";
    std::cin >> password;

    cin ==>see-in
    >> ==>get from

*recompile after any changes


    CONDITIONALS
    =================

*if
    #include <iostream>
    int main() {
    int grade = 90;
    if(grade > 60){
        std::cout << "Pass\n";
    }}

*relational Operators
    ==, !=, >, <, >=, <=

*else, else if

*switch statement
    switch (grade) {
    case 9:
        std::cout << "Freshman\n";
        break;
    case 10:
        std::cout << "Sophomore\n";
        break;
    case 11:
        std::cout << "Junior\n";
        break;
    case 12:
        std::cout << "Senior\n";
        break;
    default:
        std::cout << "Invalid\n";
        break;
    }    

*Operators
    &&, ||, !

    LOOPS
    ======

*While loop
*for loop

    ERRORS
    =======
*compile-time errors
    1. syntax errors
    2. type errors

*link-time errors
    the program needs some function or library that it can't find
    found by linker
    1. using a function that was never defined
    2. Main(), instead of maine()

*linker
    combine object files into an executable files

*run-time errors
    1. division by zero/division error
    2. trying to open a file that doesn't exist

*logic errors
    1. program logic is flawed
    2. if/loop mistakes


    VECTORS
    =======

*vector
    a sequence of elements that can be accessed by index(so, sorted array?)

::
    scope resolution operator
    allows statically traverse scopes such as namespace and classes in order to reference the identifer
    resolve ambiguities pertaining to scope
    ~ it allows access to global version of variable

*creating a vector
    | std::vector | lives in the <vector> header
    1. add | #include <vector> | at the top of the program
    2. std::vector <type> name;
    so define a vector of int called calories:
        | std::vector<int> calories; |

    the type of the vector can not be changed after the declaration

*initializing a vector and giving it value
    | std::vector<double> location = {45.49646, -45.84155} |

*initializing a vector and presizing(setting the size)
    | std::vector<double> location(2); |

*index of vectors
    output a certain element
    | std::cout << vowels[3];

*add/remove element to vector
    .push_back()
        add a element to the end of the vector
    .pop_back()
        remove element from the back

*.size()
    length of the vector, how many elements
    std::cout<<grocery.size();

*operations
    loop through a vector

*#include
    preprocessor directive that tells the compiler to include certain libraries

*include files
    include functionalities from other scource files
    (like imports/exports in React?)

    1. when include your own library you write it like this
    | #include "includes/calculation.cpp" |
    (bad practice)

    2. when using C++ library you write it like this:
    | #include <iostream> |

#header files
    .h file with the exact same name with the .cpp file
    has only the signiture of the .cpp whitout showing it
    aren't being compiled, they only got included into .cpp and then got compiled

    example of a header file:
        | #include <iostream> |
        | int add(int, int);  |
        | void output_message(std::string); |

        and just say | #include "includes/calculation.h" | in the file you are importing into
        the .CPP and .h will be linked together because they have the same name during the the compliation
        just say | g++ -o main.exe main.cpp includes/calculations.cpp | to generate .exe file


    FUNCTIONS 
    ============

*build-in fucntions
    gain access by including headers like <cmath>, <string>

*calling a function
    | std::cout<< sqrt(9) << "\n"; | //output 3

*declare & Define
    | return_type function_name( any, parameters, you, have ) { |  declaration
    | // Code block here |                                          Defination
    | return output_if_there_is_any; |
}

*void
    aka subroutine, has no return value

*return types
    double, int, bool, char, std::string, std::vector
    return statement is the last line of code will execute
    | std:: string alway_blue(){ |
    |    return "blue!"; |
    | } |

*return value
    if the function is not void and has a return type:
    1. there must be a value returned from the function
    2. the returned value type must be the same as the function's type

    the value is returned to the place where the function is called

*parameters & arguments
    parameters are variables used in functions, are placeholders for input value used during function call (formal parameter)
    the value passed into the function during the function call is called argument (actual parameter)
    | void get_emergency_number(std::string emergency_number){ |
    | std::cout << "Dial " << emergency_number;} |

*multiple arguments
    1. function call must include the same number of arguments as the parameters
    2. arguments must be passed in the same order

    CODE CHALLENGES
    =====================

*raise to the power
    include <cmath>
    pow(base, exponent);

*function that returns vector
    std::vector<int> function-name(){
        
    }

    FUNCTIONS SCOPE & FLEXIBILITY
    ===============================

*scope
    the region of code that can access or view a given element

*globlal scope
    accessible throughout the program

*local scope
    only accessible inside the function

*multi-file programs
    when code grown larger, we need to declare the function at the top and define it at the bottom
    like:
        #include <iostream>
        
        // Declaration at the top:
        void eat();
        
        int main() {
        eat();
        }
        
        // Definition at the bottom:
        void eat() {
        
        std::cout << "nom nom nom\n";
        }

    move function definition to another file and leave a list of declaration above main()
    compiles files together into a single exe like this:
       | g++ main.cpp my_functions.cpp |

*getting header
    there will be too many function declarations before main() if the code keep growing
    and declare functions repeatedly in multiple files is hard to make change and maintain
    
    --move all the the function declarations to a header file, with the same name, file extension is .hpp or .h
    just add | #include "my_functions.hpp" | to the top of main.cpp

*inline functions
    usually in a header file, qualified by | inline |:

    inline 
    void eat() {
    std::cout << "nom nom\n";
    }

    | inline | advises compiler to insert the function body where the function call is

*member functions
    function inside of classes, sometimes also called "inline functions"

*default argument
    a argument is required if the function has a parameter
    asign a value to the parameter in the function declaration, it will be the default argument if no argument is given when making the function call

            // Declaration
            void intro(std::string name, std::string lang = "C++");
            
            // Definition
            void intro(std::string name, std::string lang) {
            std::cout << "Hi, my name is "
                        << name
                        << " and I'm learning "
                        << lang
                        << ".\n";
            }

        "C++" is the default argument

*default argument for functions with two parameters
    which argument corresponds with parameter based on order
    parameters with out ddefault arguments comes first
    two arguments both needs to be call with function with two default arguments
    if
        first argument is the default value & the second argument is not default value

*functin overload
    change the way a function behaves depending on argument passed

    accept different tpyes of arguments
    optional parameters

    multiple functions with the same name, has either different tpye of parameters
    or different number of parameters

*function templates
    overloading can be tedious
    templates is a tool allows programmer to add types as parameters

*template-based tpyes
    std::string, std::vector

*create function templates
    entirely created in header files
    type is chosen tight when the function is called
    type chosen can be applied the return type, parameter type or both

    templates slow down compile time but speed up the execution time

        .cpp
        int get_smallest(int num1, int num2) {
        return num2 < num1? num2 : num1;
        }
        double get_smallest(double num1, double num2) {
        return num2 < num1? num2 : num1;
        }

        .hpp
        int get_smallest(int num1, int num2);
        double get_smallest(double num1, double num2);

        can be turn into:

        .hpp
        template <typename T>
        T get_smallest(T num1, T num2) {
        return num2 < num1? num2 : num1;
        }


    CLASS & OBJECTS
    =================================

*data

*object
    an object is just a very compilcated data type
    (attributes and functions)
    a instance of class

*class
    is a blueprint of objects
    describes objects
    C++'s original name is C with Classes
    user-defined types

*class members
    components of classes
    access class members using the dot operator
    | object.class_member |

    two kinds of class members
        1. Attributes
        2. Methods

*define methods outside a class
    method must be declared inside the class
    | ClassName:: | before the method name to indicate its class.

            int City::get_population() {
            return population;
            }

    and include the header file in the .cpp file where method is defined
    song.hpp:
        #include <string>

        class Song{
        std::string title; 
        public:
        void add_title(std::string new_title);
        std::string get_title();
        };

    song.cpp
        #include "song.hpp"

        void Song::add_title(std::string new_title){
        title = new_title;
        }
        std::string Song::get_title(){
        return title;
        }

*create object
    instantiation of the object

    main.cpp:

            #include <iostream>
            #include "song.hpp"

            int main() {
            Song electric_relaxation;
            electric_relaxation.add_title("Electric Relaxation");
            std::cout <<electric_relaxation.get_title();
            }

*access control
    public and private
    everything is private in a class by default(class members are limited to the scope of the class), keeps data from mistakenly being altered

    | public: | to make everything below accessible globally
    | private: | to make something below public to be private

*constructors
    special kind of method that lets you decide how the object of a class get created.(sets attributes when being created)
    same name as the class and no return type
    great for instantiate an object with specific attributes

        city.cpp

        City::City(std::string new_name, int new_pop)
        : name(new_name), population(new_pop) {}

    that is called member initialization list

        or

        City::City(std::string new_name, int new_pop) {
        name = new_name;
        population = new_pop;
        }

        main.cpp
            #include <iostream>
            #include "song.hpp"

            int main() {
            Song back_to_black("Back to Black", "Amy Winehouse");        

        song.hpp
            #include "song.hpp"

            Song::Song(std::string new_title, std::string new_artist){
            title = new_title;
            artist = new_artist;
            }

            std::string Song::get_title() {
            return title;
            }

            std::string Song::get_artist() {
            return artist;
            }

        song.cpp
            #include "song.hpp"

            Song::Song(std::string new_title, std::string new_artist){
            title = new_title;
            artist = new_artist;
            }

            std::string Song::get_title() {
            return title;
            }

            std::string Song::get_artist() {
            return artist;
            }

*destructors
    prevents memory leaks, execute clean up necessary
    will be called automatically if:
        1. the object moves out of scoope
        2. the object is explicitly deleted
        3. program ended

    city.hpp
        public:
        City(std::string new_name, int new_pop);
        ~City();
        };

    city.cpp
        City::~City() {
        // any final cleanup
        }

    song.cpp
        #include "song.hpp"
        #include <iostream>

        Song::Song(std::string new_title, std::string new_artist) 
        : title(new_title), artist(new_artist) {}

        Song::~Song(){
        std::cout<< "Goodbye "<< title <<"!";
        }


    REFERENCES & POINTERS
    =================================

*computer memory
    a sequence of bytes, can be numbered from 0 to the last

*address
    each number of the bytes is an address
    is a location in the memory
    everything put into the memory has a address

    int power = 900000;
    set aside a int-size piece of memory for the variable power and put the value 900000
    into that memory

*refernces and pointers
    some of the most powerful features in C++
    allow programmers to directly manipulate memory to optimize performance

*references

    an alias (a other name)for a variable
    thing did to the reference also happens to the original
    aliases can't be changed to alias something else

    use &before the variable name

        making pop a reference to soda:

        #include <iostream>

        int main() {
        
        int soda = 99;
        int &pop = soda;
        pop++;
        std::cout << soda << pop;
        }

*pass-by-reference
    using references as parameters allows us to modify the argument's values
        void swap_num(int &i, int &j) {
        
        int temp = i;
        i = j;
        j = temp;
        
        }
        
        int main() {
        
        int a = 100;
        int b = 200;
        
        swap_num(a, b);
        
        std::cout << "A is " << a << "\n";
        std::cout << "B is " << b << "\n";
        
        }

        #include <iostream>


        int triple(int &i) {

        i = i * 3;
        
        return i;

        }

        int main() {
        
        int num = 1;
        
        std::cout << triple(num) << "\n";
        std::cout << triple(num) << "\n";

        }

*pass-by-value
    pass parameters to a function, using normal variables

*const
    tells the compiler that the variable won't be changed
    | double const pi = 3.14; |//error thrown if trying to change pi

*const in function parameter
    we know that the parameter won't change inside the function

        int triple(int const i) {
        return i * 3;
        }//i is not modified

*const reference
    to save computational cost:

        int triple(int const &i) {
        return i * 3;
        }//i is not modified, by making i a reference to the argument, not needing to making copy of the argument

*memory address
    & is also used to get the memory address, the "address of" operator
    find out where the variable is stored
    
    | std::cout << &porcupine_cout << "\n"; |
    // returns something like: 0x7ffd7caa5b54 (hexadecimal, instead of binary for readability and conciseness.)

    1. when & is used in a declaration:
        reference operator
    2. when & is not used in a declaration:
        address operator

*pointers
    a pointer stores a memory address
    inherited from C, avoid pointers as much as possible, usually a reference will do the trick
    pointers must be declared before they can be used, marked by*
    | int* number |
    | double* decimal |
    | char* character |

    a variable called gum:
        int gum = 8;
    create a pointer to it:
        int* ptr = &gum;

    1. int* makes it a pointer rather than a normal variable
    2. ptr* is the pointer name
    3. &gum is the memory address of the variable--gum's memory address

*dereference operator
    | * |
    to obtain the value the point pointed to

        #include <iostream>

        int main() {
        
        int power = 9000;
        
        // Create pointer
        int* ptr = &power;
        
        // Print ptr
        std::cout << ptr << "\n";//memory address
        
        // Print *ptr
        std::cout << *ptr << "\n";//9000
        
        }

        1. when * is used in a declaration, it's creating a pointer
        2. wehn * is not used in a declaration, it's a dereference operator

*null pointer
    can't just declare a pointer variable and not intialize it like this:
    | int* ptr; |
    it need to be assigned a valid address, it can't be "nowhere" or "somewhere"

    | nullptr | is an empty pointer:
    | int* ptr = nullptr; |

*review
        // Reference
        int &reference = original;
        
        // Pointer
        int* pointer = &original;


    Visual Studio
    =============

*desktop dev
    
*plug-ins
    resharper++, student license is free

*solution
    a group of project that are related to each other
    or workbench

*project
    group of file that compiler into binary
    .exe or library

*source file
    add new for files
    main()

*build, rebuild
    generate .exe

*debug
    F5

*#
    pre-processor statement, happen just before the compilation

*include <iostream>
    find this file <file> and paste the content into the current file
    usually the header files

*<iostream>
    has the declarations like cout

*int main()
    entry point of the program
    main() is special case, it doesn't return a int, if not returning anything,
    it will assume returning zero

*<<
    overloaded operator, think them as a function
    operators are just functions
    same as .print() or push right into left

*solution configuration
    set of rules that applies to the program for the platform
    debug or release
    debug's optimization is turned off, there for, slower

*solution platform
    x64==> win63
    x86==> win32
    android
    what platform is the compilation targeting

*.cpp
    compiled into .obj files individually

*compile individual files
    VS ctrl+F7

*error list
    mostly useless

*output window
    is better for error screening


    