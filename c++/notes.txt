    WELCOME
    =========

*C++
    compiler ==> machine code
    hardware, game dev, fast, lower level

*java, C#
    compiler ==> visual machine ==> machine code


*HELLO WORLD FROM C++

    #include <iostream> ==>include libraries
    int main() {        ==>Main function
    std::cout << "Hello World!\n";  ==>function body
    }


@ OUTPUT

*execution
    top to down, line by line

*std::cout <<"Hello World!\n";
    std::cout ==>Standard(namespace), character output stream, pronounced "see-out"
    :: ==>scope
    << ==>operator
    "Hello World?\n" ==>is what being output, double quotes around text. \n indicates a new line.
    ; ==>end the statement

*namespace
    a set of signs(names)that are used to identify and refer to objects of various kinds.


@ PATTERN
    
*/n
    can print out several lines with one fucntion

@ COMPILE AND EXECUTE

*C++ is a compiled language, source code => compile => machine code => execute.

*compile
    turn/translate source code into machaine code

*g++
    type |g++ app-name.cpp| into terminal to call on the compiler

*execute
    type |./machine-code-file-name.out| in terminal

*process
    executable file => loaded to CPU => line by line


@ NAMING EXECUTABLES
    
*name executable & output & execute
    |g++ hello.cpp -o name-of-the-executable| 
    then
    |./name-of-the-executable| to execute

*COMMENTS
    |// comments here!|
    |/*comment,
    comment,
    comment.*/|

*source code suffix
    .cpp
    .h

    VARIABLE
    =========

*declare
    name+type
    | int score; |

*strongly typed
    
*initialize
    | score = 0; |

*arthmetic Operators
    +, -, *, /, %

*print out the value of variable
    std::cout << score << "\n";

*chaining
    int age = 28;
    std::cout << "Hello, I am ";
    std::cout << age;
    std::cout << " years old\n";
    output ==> Hello, I am 28 years old
    can be written as ==> std::cout << "Hello, I am " << age << " years old\n";

    #include <iostream>
    int main() { 
    int score = 0;
    std::cout << "Player score: " << score <<"\n";   
    }

*user input
    std::cout << "Enter your password: ";
    std::cin >> password;

    cin ==>see-in
    >> ==>get from

*recompile after any changes


    CONDITIONALS
    =================

*if
    #include <iostream>
    int main() {
    int grade = 90;
    if(grade > 60){
        std::cout << "Pass\n";
    }}

*relational Operators
    ==, !=, >, <, >=, <=

*else, else if

*switch statement
    switch (grade) {
    case 9:
        std::cout << "Freshman\n";
        break;
    case 10:
        std::cout << "Sophomore\n";
        break;
    case 11:
        std::cout << "Junior\n";
        break;
    case 12:
        std::cout << "Senior\n";
        break;
    default:
        std::cout << "Invalid\n";
        break;
    }    

*Operators
    &&, ||, !

    LOOPS
    ======

*While loop
    if the loop condition is complicated, or loops nearly indefinitely
    not if the change is complicated

    condition doesn't fit in the sign line of for loop:
        int j = 5;
         for ( int i = 0; i < 10 && j > 0; i++ )
         {
        cout << i * j; j = i - j;
         }

    better to do this
        int i = 0;
         int j = 5;
         while ( i < 10 && j > 0 )
         {
        cout << i * j;
        j = i - j; 
        i++;
        }


*for loop
    if you know the exact number of the times want it to loop
    counting from 0 to 100
    not if variable needs to be updated in a complicated way

*do-while loop
    fairly rare, a reversed while loop
    make it easy to write the loop body that happends at least once
        do
        {
        //body...
        }while(condition);
    condition is tested at the END of the loop body
    the loop will be execute at least once
    
*break
    immediately end the loop, jump to the closing brace
    escape route from within a large loop
*continue
    ends the current iteration early, but doesn't exit the loop
    skip some code in the middle of the body of a loop

*nested loops
    -outer loop
    -inner loop
    
*'\t'
    tab char


    ERRORS
    =======
*compile-time errors
    1. syntax errors
    2. type errors

*link-time errors
    the program needs some function or library that it can't find
    found by linker
    1. using a function that was never defined
    2. Main(), instead of maine()

*linker
    combine object files into an executable files

*run-time errors
    1. division by zero/division error
    2. trying to open a file that doesn't exist

*logic errors
    1. program logic is flawed
    2. if/loop mistakes


    VECTORS
    =======

*vector
    a sequence of elements that can be accessed by index(so, sorted array?)

::
    scope resolution operator
    allows statically traverse scopes such as namespace and classes in order to reference the identifer
    resolve ambiguities pertaining to scope
    ~ it allows access to global version of variable

*creating a vector
    | std::vector | lives in the <vector> header
    1. add | #include <vector> | at the top of the program
    2. std::vector <type> name;
    so define a vector of int called calories:
        | std::vector<int> calories; |

    the type of the vector can not be changed after the declaration

*initializing a vector and giving it value
    | std::vector<double> location = {45.49646, -45.84155} |

*initializing a vector and presizing(setting the size)
    | std::vector<double> location(2); |

*index of vectors
    output a certain element
    | std::cout << vowels[3];

*add/remove element to vector
    .push_back()
        add a element to the end of the vector
    .pop_back()
        remove element from the back

*.size()
    length of the vector, how many elements
    std::cout<<grocery.size();

*operations
    loop through a vector

*#include
    preprocessor directive that tells the compiler to include certain libraries

*include files
    include functionalities from other scource files
    (like imports/exports in React?)

    1. when include your own library you write it like this
    | #include "includes/calculation.cpp" |
    (bad practice)

    2. when using C++ library you write it like this:
    | #include <iostream> |

#header files
    .h file with the exact same name with the .cpp file
    has only the signiture of the .cpp whitout showing it
    aren't being compiled, they only got included into .cpp and then got compiled

    example of a header file:
        | #include <iostream> |
        | int add(int, int);  |
        | void output_message(std::string); |

        and just say | #include "includes/calculation.h" | in the file you are importing into
        the .CPP and .h will be linked together because they have the same name during the the compliation
        just say | g++ -o main.exe main.cpp includes/calculations.cpp | to generate .exe file


    FUNCTIONS 
    ============

*build-in fucntions
    gain access by including headers like <cmath>, <string>

*calling a function
    | std::cout<< sqrt(9) << "\n"; | //output 3

*declare & Define
    | return_type function_name( any, parameters, you, have ) { |  declaration or the prototype
    | // Code block here |                                          Defination
    | return output_if_there_is_any; |
}

*void
    aka subroutine, has no return value

*return types
    double, int, bool, char, std::string, std::vector
    return statement is the last line of code will execute
    | std:: string alway_blue(){ |
    |    return "blue!"; |
    | } |

*return value
    if the function is not void and has a return type:
    1. there must be a value returned from the function
    2. the returned value type must be the same as the function's type

    the value is returned to the place where the function is called

*parameters & arguments
    parameters are variables used in functions, are placeholders for input value used during function call (formal parameter)
    the value passed into the function during the function call is called argument (actual parameter)
    | void get_emergency_number(std::string emergency_number){ |
    | std::cout << "Dial " << emergency_number;} |

*multiple arguments
    1. function call must include the same number of arguments as the parameters
    2. arguments must be passed in the same order

    CODE CHALLENGES
    =====================

*raise to the power
    include <cmath>
    pow(base, exponent);

*function that returns vector
    std::vector<int> function-name(){
        
    }

    FUNCTIONS SCOPE & FLEXIBILITY
    ===============================

*scope
    the region of code that can access or view a given element

*globlal scope
    accessible throughout the program

*local scope
    only accessible inside the function

*multi-file programs
    when code grown larger, we need to declare the function at the top and define it at the bottom
    like:
        #include <iostream>
        
        // Declaration at the top:
        void eat();
        
        int main() {
        eat();
        }
        
        // Definition at the bottom:
        void eat() {
        
        std::cout << "nom nom nom\n";
        }

    move function definition to another file and leave a list of declaration above main()
    compiles files together into a single exe like this:
       | g++ main.cpp my_functions.cpp |

*getting header
    there will be too many function declarations before main() if the code keep growing
    and declare functions repeatedly in multiple files is hard to make change and maintain
    
    --move all the the function declarations to a header file, with the same name, file extension is .hpp or .h
    just add | #include "my_functions.hpp" | to the top of main.cpp

*inline functions
    usually in a header file, qualified by | inline |:

    inline 
    void eat() {
    std::cout << "nom nom\n";
    }

    | inline | advises compiler to insert the function body where the function call is

*member functions
    function inside of classes, sometimes also called "inline functions"

*default argument
    a argument is required if the function has a parameter
    asign a value to the parameter in the function declaration, it will be the default argument if no argument is given when making the function call

            // Declaration
            void intro(std::string name, std::string lang = "C++");
            
            // Definition
            void intro(std::string name, std::string lang) {
            std::cout << "Hi, my name is "
                        << name
                        << " and I'm learning "
                        << lang
                        << ".\n";
            }

        "C++" is the default argument

*default argument for functions with two parameters
    which argument corresponds with parameter based on order
    parameters with out ddefault arguments comes first
    two arguments both needs to be call with function with two default arguments
    if
        first argument is the default value & the second argument is not default value

*function overload
    change the way a function behaves depending on argument passed
    only overload it if two functions do the same thing but do it to the different arguments

    accept different tpyes of arguments
    optional parameters

    multiple functions with the same name, has either different tpye of parameters
    or different number of parameters

*function templates
    overloading can be tedious
    templates is a tool allows programmer to add types as parameters

*template-based tpyes
    std::string, std::vector

*create function templates
    entirely created in header files
    type is chosen tight when the function is called
    type chosen can be applied the return type, parameter type or both

    templates slow down compile time but speed up the execution time

        .cpp
        int get_smallest(int num1, int num2) {
        return num2 < num1? num2 : num1;
        }
        double get_smallest(double num1, double num2) {
        return num2 < num1? num2 : num1;
        }

        .hpp
        int get_smallest(int num1, int num2);
        double get_smallest(double num1, double num2);

        can be turn into:

        .hpp
        template <typename T>
        T get_smallest(T num1, T num2) {
        return num2 < num1? num2 : num1;
        }


    CLASS & OBJECTS
    =================================

*data

*object
    an object is just a very compilcated data type
    (attributes and functions)
    a instance of class

*class
    is a blueprint of objects
    describes objects
    C++'s original name is C with Classes
    user-defined types

*class members
    components of classes
    access class members using the dot operator
    | object.class_member |

    two kinds of class members
        1. Attributes
        2. Methods

*define methods outside a class
    method must be declared inside the class
    | ClassName:: | before the method name to indicate its class.

            int City::get_population() {
            return population;
            }

    and include the header file in the .cpp file where method is defined
    song.hpp:
        #include <string>

        class Song{
        std::string title; 
        public:
        void add_title(std::string new_title);
        std::string get_title();
        };

    song.cpp
        #include "song.hpp"

        void Song::add_title(std::string new_title){
        title = new_title;
        }
        std::string Song::get_title(){
        return title;
        }

*create object
    instantiation of the object

    main.cpp:

            #include <iostream>
            #include "song.hpp"

            int main() {
            Song electric_relaxation;
            electric_relaxation.add_title("Electric Relaxation");
            std::cout <<electric_relaxation.get_title();
            }

*access control
    public and private
    everything is private in a class by default(class members are limited to the scope of the class), keeps data from mistakenly being altered

    | public: | to make everything below accessible globally
    | private: | to make something below public to be private

*constructors
    special kind of method that lets you decide how the object of a class get created.(sets attributes when being created)
    same name as the class and no return type
    great for instantiate an object with specific attributes

        city.cpp

        City::City(std::string new_name, int new_pop)
        : name(new_name), population(new_pop) {}

    that is called member initialization list

        or

        City::City(std::string new_name, int new_pop) {
        name = new_name;
        population = new_pop;
        }

        main.cpp
            #include <iostream>
            #include "song.hpp"

            int main() {
            Song back_to_black("Back to Black", "Amy Winehouse");        

        song.hpp
            #include "song.hpp"

            Song::Song(std::string new_title, std::string new_artist){
            title = new_title;
            artist = new_artist;
            }

            std::string Song::get_title() {
            return title;
            }

            std::string Song::get_artist() {
            return artist;
            }

        song.cpp
            #include "song.hpp"

            Song::Song(std::string new_title, std::string new_artist){
            title = new_title;
            artist = new_artist;
            }

            std::string Song::get_title() {
            return title;
            }

            std::string Song::get_artist() {
            return artist;
            }

*destructors
    prevents memory leaks, execute clean up necessary
    will be called automatically if:
        1. the object moves out of scoope
        2. the object is explicitly deleted
        3. program ended

    city.hpp
        public:
        City(std::string new_name, int new_pop);
        ~City();
        };

    city.cpp
        City::~City() {
        // any final cleanup
        }

    song.cpp
        #include "song.hpp"
        #include <iostream>

        Song::Song(std::string new_title, std::string new_artist) 
        : title(new_title), artist(new_artist) {}

        Song::~Song(){
        std::cout<< "Goodbye "<< title <<"!";
        }


    REFERENCES & POINTERS
    =================================

*computer memory
    a sequence of bytes, can be numbered from 0 to the last

*address
    each number of the bytes is an address
    is a location in the memory
    everything put into the memory has a address

    int power = 900000;
    set aside a int-size piece of memory for the variable power and put the value 900000
    into that memory

*refernces and pointers
    some of the most powerful features in C++
    allow programmers to directly manipulate memory to optimize performance

*references

    an alias (a other name)for a variable
    thing did to the reference also happens to the original
    aliases can't be changed to alias something else

    use &before the variable name

        making pop a reference to soda:

        #include <iostream>

        int main() {
        
        int soda = 99;
        int &pop = soda;
        pop++;
        std::cout << soda << pop;
        }

*pass-by-reference
    using references as parameters allows us to modify the argument's values
        void swap_num(int &i, int &j) {
        
        int temp = i;
        i = j;
        j = temp;
        
        }
        
        int main() {
        
        int a = 100;
        int b = 200;
        
        swap_num(a, b);
        
        std::cout << "A is " << a << "\n";
        std::cout << "B is " << b << "\n";
        
        }

        #include <iostream>


        int triple(int &i) {

        i = i * 3;
        
        return i;

        }

        int main() {
        
        int num = 1;
        
        std::cout << triple(num) << "\n";
        std::cout << triple(num) << "\n";

        }

*pass-by-value
    pass parameters to a function, using normal variables

*const
    tells the compiler that the variable won't be changed
    | double const pi = 3.14; |//error thrown if trying to change pi

*const in function parameter
    we know that the parameter won't change inside the function

        int triple(int const i) {
        return i * 3;
        }//i is not modified

*const reference
    to save computational cost:

        int triple(int const &i) {
        return i * 3;
        }//i is not modified, by making i a reference to the argument, not needing to making copy of the argument

*memory address
    & is also used to get the memory address, the "address of" operator
    find out where the variable is stored
    
    | std::cout << &porcupine_cout << "\n"; |
    // returns something like: 0x7ffd7caa5b54 (hexadecimal, instead of binary for readability and conciseness.)

    1. when & is used in a declaration:
        reference operator
    2. when & is not used in a declaration:
        address operator

*pointers
    a pointer stores a memory address
    inherited from C, avoid pointers as much as possible, usually a reference will do the trick
    pointers must be declared before they can be used, marked by*
    | int* number |
    | double* decimal |
    | char* character |

    a variable called gum:
        int gum = 8;
    create a pointer to it:
        int* ptr = &gum;

    1. int* makes it a pointer rather than a normal variable
    2. ptr* is the pointer name
    3. &gum is the memory address of the variable--gum's memory address

*dereference operator
    | * |
    to obtain the value the point pointed to

        #include <iostream>

        int main() {
        
        int power = 9000;
        
        // Create pointer
        int* ptr = &power;
        
        // Print ptr
        std::cout << ptr << "\n";//memory address
        
        // Print *ptr
        std::cout << *ptr << "\n";//9000
        
        }

        1. when * is used in a declaration, it's creating a pointer
        2. wehn * is not used in a declaration, it's a dereference operator

*null pointer
    can't just declare a pointer variable and not intialize it like this:
    | int* ptr; |
    it need to be assigned a valid address, it can't be "nowhere" or "somewhere"

    | nullptr | is an empty pointer:
    | int* ptr = nullptr; |

*review
        // Reference
        int &reference = original;
        
        // Pointer
        int* pointer = &original;


    Visual Studio
    =============

*desktop dev
    
*plug-ins
    resharper++, student license is free

*solution
    a group of project that are related to each other
    or workbench

*project
    group of file that compiler into binary
    .exe or library

*source file
    add new for files
    main()

*build, rebuild
    generate .exe

*debug
    F5

*#
    pre-processor statement, happen just before the compilation

*include <iostream>
    find this file <file> and paste the content into the current file
    usually the header files

*<iostream>
    has the declarations like cout

*int main()
    entry point of the program
    main() is special case, it doesn't return a int, if not returning anything,
    it will assume returning zero

*<<
    insertion operator
    overloaded operator, think them as a function
    operators are just functions
    same as .print() or push right into left

*solution configuration
    set of rules that applies to the program for the platform
    debug or release
    debug's optimization is turned off, there for, slower

*solution platform
    x64==> win63
    x86==> win32
    android
    what platform is the compilation targeting

*.cpp
    compiled into .obj files individually

*compile individual files
    VS ctrl+F7

*error list
    mostly useless

*output window
    is better for error screening

*endl
    end line
*\n
    new line

*types
    char
    int
    double

*declare multiple
    int a, b, c, d;

*cin.ignore();
    reads and discards a char
    
*initialize all variable rightaway
    int x = 0;

*string
    not in the compiler, is in the C++ standard library
    #include <string>
    string myString

*string appending
    concatenate
    +

*getline()
    getline(cin, userInput, "\n");
    getline(cin, userInput, ",");
    parameters are source of input, the string to read into, and the char to terminate input

*bit
    on/off switch
    either 1 or 0

*byte
    is made up of eight bits
    256 possible configurations of 1 and 0
    2 raised to the power of 8
    2 bytes = 16 bits, 2 raised to the power of 16(65536) value

    -char
        one byte, 256 values
    -int
        4 bytes, 4 billion different numbers
    -float
        4 bytes
    -double
        8 bytes, double is always better

*enumeration
    variable can take on just a few value, and the values are known ahead of time
    -enums
        enumerated type, just int behind the scenes
        give names to values that otherwise need to be hard coded
        a variable type to create with a fixed list of values(colors of rainbow)

            enum RainbowColor{
                RC_RED, 
                RC_ORANGE, 
                RC_YELLOW, 
                RC_GREEN, 
                RC_BLUE, 
                RC_INDIGO, 
                RC_VIOLET
            };

        declare a special variable of the type RainbowColor:
            
            RainbowColor chosen_color = RC_RED;
    
        work with switch case:

            switch(chose_color){
             case RC_RED: /* paint screen red */
             case RC_ORANGE: /* paint screen orange */
             case RC_YELLOW: /* paint screen yellow */
             case RC_GREEN: /* paint screen green */
             case RC_BLUE: /* paint screen blue */
             case RC_INDIGO: /* paint screen indigo */
             case RC_VIOLET: /* paint screen violet */
             default: /* handle unexpected types */
             }

*randomization
    1. user input
    2. program generate(pseudo-random numbers)

*pseudo-random numbers
    seed =math=> new seed

*void srand(int seed);
    call it at the start of the program
    | srand(time(NULL)); |
    must include headers | cstdlib |, | ctime |

*limit range of random num
    srand(time(NULL)); will give you between 0 and 32767(RAND_MAX)
    using modulus operator

    HOW TO PRACTICE
    ================

*think in algorithm
    series of steps required to solve a problem

*break problems into chunks
    -problem like print out prime numbers from 1 to 100
        clearly more than a single operation:
        1. go over all numbers between 1 to 100
            -that's a for loop

                for ( int i = 0; i < 100; i++ )
                 {
                // check whether i is prime? If it is, print it
                 }

        2. each number is tested whether is prime
        3. if the number is prime, print it out
            -use a function, and cout

                for ( int i = 0; i < 100; i++ )
                 {
                if ( isPrime( i ) ) { 
                cout << i << endl; 
                 }
                }

            isPrime()
            -that's the structure, now zoom in step 2
                prime num: if it has no divisors other than 1 and itself
                check if any number divides it evenly other than 1 and itself
                    -using a second loop
                    1. for each num between 1 and the num being tested
                    2. check if it's divisible by the loop variable
                    3. if it is, false
                    4. if no divisor, true

                    -translate that into code:

                        bool isPrime (int num)
                         {
                            for ( int i = 2; i < num; i++) { 
                                if ( isDivisible( num, i ) ) { 
                                return false; 
                                } } 
                            return true;
                             }

                isDivisble()
                -use modulo %, and if there's remainder

                    bool isDivisible (int number, int divisor)
                     {
                    return num % divisor == 0;
                    }

    -sometimes it's impossible to solve sub-problems
        take a step back and try to find other ways

*top-down design
    breaking down program into manageable parts

*bottom-up design
    individual parts of the system are specified in detail. 
    The parts are linked to form larger components, 
    which are in turn linked until a complete system is formed.

*helper function
    functions that will be reused again and again, and might apply to other classes

*efficiency
    the algorithm above could be more efficient, 
    like isPrime can only check 2 to square root of num

*RSA
    generate large number of prime numbers to create encryption keys

*bigger picture
    design on whiteboard or paper
    Doing your design directly with code can sometimes obscure the big picture
    as you work on sorting out each tiny little piece of the syntax that you need.

*find the patten
    write out a couple of examples, think about the similarities/differences

    -some execises
         1  Implement the source code that turns numbers into English text for numbers between -999,999 and 999,999. (Hint: You might also be able to take advantage of the fact that the integer data type will truncate decimal points. Also, remember that your algorithm doesn’t have to work for all numbers—only numbers with six digits or less. )
         2  Think about how you would go in the opposite direction, reading English text and translating it into numbers. Is this easier or harder than the earlier algorithm? How would you handle bad input?
         3  Design a program that finds all numbers from 1 to 1000 whose prime factors, when added together, sum up to a prime number (for example, 12 has prime factors of 2, 2, and 3, which sum to 7, which is prime). Implement the code for that algorithm. (Hint: If you don’t know the algorithm to find the prime factors of a number and have trouble figuring it out, it’s OK to look it up on Google! I meant it when I told you that you don’t need to know math to be a programmer.)

    DATA
    ===========================

*array
    a variable with a single name that can store multiple values
    (a numbered list)
    | int myArray[6]; | ==> declare array named myArray with 6 int elements
    | myArray[3]; | access 4th element
    
*multidimensional array
    grid shaped
    | int ticTacToeBoard[2][3]; |

*array and for loop
    loop through array

*passing array to function
    int sumArray (int value[]);
    arrays passed into a function will be modified, not like normal variables, are copied into the function and the original is not affected

    -if function need to know the size of the array
        | int sumArray(int value[], int size);

*sorting array
    insertion sort

    STRUCTURES
    =================

*structures
    better way of associating values together
    store different values in variable under the same name
    -syntax:

        struct SpaceShip
         {
            int x_coordinate; <-field
            int y_coordinate; 
            string name;
         }; // <- Notice that pesky semicolon; you must include it

         SpaceShip my_ship; <-declare a variable

         my_ship.x_coordinate = 40;  <-using it
         my_ship.y_coordinate = 40;
         my_ship.name = "USS Enterprise (NCC-1701-D)";

*struct with array
    array of structs
    | player[0].name; |

*passing struct around
    receives a struct as argument or returns a strcut
    when struct passed into a function it's just a copy, the function need to return a copy, original is not changed
    to overwrite the original strcut:
        | ship = upgradeWeapons( ship ); |

    POINTER IN DEPTH
    ===========================

*memory
    normal variable's memory is fixed, chosen at compile time
    a large num of sequenital pieces of data, each cell stores 1 byte
    linearly organized, long array of chars
    each cell has an address, which point stores

*pointers
    refer driectly to the memory that stores variable
    "point to" a location in memory, similar to a hyperlink
    sending a "link" to the variable rather than making a copy
    like arrays, when they got passed into functions they aren't copied
    always initiate the point before using it

*variable & address
    a variable is a representation of a value
    the value is stored at a particular location in memory, has a memory address
    
    access the memory address of a variable:
        | &number; |

*stack
    parts of memory used to store the variables that declared and being used
    
*heap(free store)
    unallocated memory that can request in chuncks
    managed by the OS

*owner (of tha memory)
    part of the code responsible for relasing a piece of memory
    retrun it to the free store
    program will eventually run of out memory(memory leak)
    ==> slowdown & crashes

    when writing a function that takes a pointer, 
    whether the function take ownership should be documents

    POINTER SYNTAX
    ==========================

*declare a pointer
    type *ptr_name;
    -int *pointerToInteger;
    ! how to make pointer variable name clear

*pointing to something
    getting the address of a variable

*& ampersand
    "address of" operator
    | int *p_x = & x; |
    using '&' is like looking up the URL address of a website
    rather than staring at the contents of the the webpage
    most of the time, all you want from a variable is its actual value

*using a pointer
    two things you can do with pointer:
    1. request the memory location the pointer stores
    2. request the value stored at that memory location
    -pointer is an memory address
    -*pointer to access the value at that memory location(dereferencing the pointer)
    
    1. A pointer stores an address, so when you use the bare pointer, 
    you get that address back. You have to add something extra, 
    the asterisk, in order to retrieve or modify the value stored at the address.
    
    2. A variable stores a value, so when you use the variable, 
    you get its value. You have to add some extra, 
    the ampersand, in order to retrieve the address of that variable.

    modify a pointer also modify the original variable

*uninitialized pointers & NULL
    always initialize pointer before use it, to prevent overwriting memory and crashing
    -“this pointer is explicitly NOT initialized yet.”:
        | int *ptr = nullptr; |

*pointer & functions
    pointer allow us to pass the address of a local variable into a function
    can then modify the variable
    -see pointer-swap-function.cpp

        take the address that stores the data
        associated with the variable
        and pass that address to the function
        instead of making a copy of the data stored in the structure

*references
    a variable that refers to another variable
    and used just like a regular variable, stripped down pointer without needing to use special syntax
    must always refer to valid memory
    avoids extra copies of large data, but don't need full power of pointers
    declared with ampersand:
        | int &ref = number; |

    the actual memory of the ref variable holds a pointer to the memory of the number variable
    compiler knows that ref want the actual value pointed to

        void swapVariable (int left, int right)
        {
	        int temp;
	        temp = left;
	        left = right;
	        right = temp;
        }//this will not work

        void swapUsingPoiner(int* p_left, int* p_right)
        {
	        int temp = *p_left;
	        *p_left = *p_right;
	        *p_right = temp;
        }//this will swap variables     

        void swapReference (int& left, int& right)
        {
            int temp = right; 
            right = left; 
            left = temp;
        }//this will work and easier to write

*references vs. pointers
    -ref is a replacement of ptr when refer to a variable by multiple names:
    1. pass argument to a function without coping them
    2. want the function to modify its parameters that is visible to the caller

    -ref has less flexibility
    1. ref must always be valid
    2. ref can't be changed the memory it refers to

    -ref almost always work with struct
    | void(myStructType& arg); |

    Dynamic Memory Allocation
    ======================================

*Dynamic allocation
    request as much memory as needed while the program running
    program will calculate the amount of memory needed instead of working fixed set of variables with a particular size

*"new" & more memory
    | new | is used to initialize pointers with memory from the free store:

        | int *p_int = new int; |

*"delete" & freeing the memory
    return the memory back to the free store

        | delete p_int; |
        | p_int = NULL; |

*running out of memory
    if you keep allocating memory and never use free it, memory will run out

*references and dynamic allocation
    should not store memory in reference

*pointers & arrays
    pointer can point to a sequence of values, can be treated like an array
    an array is, after all, a series of values laid out sequentially in memory
    you can create a new array dynamically from the free store, allowing to determine the amount needed at runtime

         int numbers[ 8 ];
         int* p_numbers = numbers;
         //use p_numbers just like an array

         int *p_numbers = new int[ 8 ];

         Using the array syntax as the argument to new 
         tells the compiler how much memory it needs—enough for an 8-element integer array

          delete[] p_numbers;
          free the memory

          how many numbers are needed and 
          then uses that variable to determine the size of the dynamically allocated array:

            int count_of_numbers;
            cin >> count_of_numbers;
            int *p_numbers = new int[ count_of_numbers ];

    memory address of the array is the same with the first element and 
    the rest adds to it [2] adds 2 position, [8] adds 8 and so on

*multidimensional arrays
    !how to allocate multidimensional data structures dynamically

*pointer arithmetic
    pointer represent memory address, memory addresses are ultimately just numbers
    so you can perform mathematical operations on pointer
        -add a number and a pointer
        -subtract two pointers
            !when want to write a block of memory, and know the exact offset into which wish to place a value
            -array, pointer arithmetic:

                int x[10];
                x[3] = 120;

            ==>set the 3rd memory slot to the value 120
            the bracket operator is just syntactic sugar, it's the same as:

                *(x+3) = 120;

            ==> adding 3 * sizeof(int) to x, sizeof is a special keyword gives the size, in bytes, of a variable of type
            adding in increments of the variable size prevents you from accidentally using pointer arithmetic
            to write/read between two values(-the last two bytes of one slot and the first two bytes of another)

    should use array syntax rather than trying to get the pointer arithmetic correct
    understanding pointer arithmetic makes it easier to do sophisticated stuff

*two-dimensional arrays
    actually laid out flat in memory, the compiler lets you treat it as square block of memory, but it's really just a linear collection of address

    this:
        [0][0][0][0]
        [1][1][1][1]
        [2][2][2][2]
        [3][3][3][3]

    is actually this:
        [0][0][0][0][1][1][1][1][2][2][2][2][3][3][3][3]

    array[3][2] turns into pointer arithmetic:
    *(array + 3 * < width of array > +2)

    that's why you need the second array size passing a two-dimensional array as argument, with out the width of the array, the math won't work

